using Combinatorics
using LinearAlgebra

"""
    Solution

A structure to hold an eigenpair solution.

# Fields
- `λ::ComplexF64`: The eigenvalue.
- `vec::Vector{ComplexF64}`: The eigenvector.
"""
struct Solution
    λ::ComplexF64
    vec::Vector{ComplexF64}
end

"""
    parse_solutions(filename::String) -> Vector{Solution}

Parses a solution file generated by the solver and returns a list of `Solution` objects.

# Arguments
- `filename::String`: Path to the solution file.
"""
function parse_solutions(filename::String)
    sols = Solution[]
    if !isfile(filename)
        println("Warning: File $filename not found.")
        return sols
    end
    
    txt = read(filename, String)
    # Split by "--- Solution"
    blocks = split(txt, "--- Solution")[2:end] # Skip preamble
    
    for b in blocks
        # Extract λ
        m_λ = match(r"λ\s*=\s*([^\n]+)", b)
        if m_λ === nothing
            continue
        end
        λ_str = replace(m_λ.captures[1], "im" => "im", " " => "")
        λ_val = parse(ComplexF64, λ_str)
        
        # Extract vector
        m_vec = match(r"x\s*=\s*\[\s*([^\]]+)\]", b)
        if m_vec !== nothing
            vec_str = m_vec.captures[1]
            lines = split(strip(vec_str), "\n")
            # Parse components
            v_comps = [parse(ComplexF64, replace(strip(l), "im" => "im", " " => "")) for l in lines]
            push!(sols, Solution(λ_val, v_comps))
        end
    end
    return sols
end

"""
    is_parallel(v1, v2; tol=1e-4) -> Bool

Checks if two 2D vectors are parallel (cross product is zero within tolerance).
"""
function is_parallel(v1, v2; tol=1e-4)
    # Cross product for 2D vectors: x1*y2 - x2*y1 = 0
    det = v1[1]*v2[2] - v1[2]*v2[1]
    return abs(det) < tol
end

"""
    kronecker_product(A::AbstractArray, B::AbstractArray) -> AbstractArray

Computes the Kronecker product of two tensors A and B.
Ensures both tensors have the same number of dimensions.
"""
function kronecker_product(A::AbstractArray, B::AbstractArray)
    # Get the sizes of the input tensors
    sA = size(A)
    sB = size(B)

    # Ensure the tensors have the same number of dimensions
    if ndims(A) != ndims(B)
        error("Input tensors must have the same number of dimensions. Got $(ndims(A)) and $(ndims(B))")
    end

    A_repeated = repeat(A, inner=sB)
    B_repeated = repeat(B, outer=sA)

    return A_repeated .* B_repeated
end

"""
    generate_symmetric_tensor(dim::Int, size::Tuple) -> Array{Float64}

Generates a random symmetric tensor.

# Arguments
- `dim::Int`: Order of the tensor (number of dimensions).
- `size::Tuple`: Size of each dimension (must be equal).
"""
function generate_symmetric_tensor(dim::Int, size_tuple::Tuple)
    tensor = zeros(size_tuple)
    n = size_tuple[1]
    # This implementation assumes all dimensions have the same size
    if !all(s -> s == n, size_tuple)
        error("generate_symmetric_tensor requires all dimensions to have the same size.")
    end

    # Iterate through canonical indices (where i_1 <= i_2 <= ... <= i_d)
    for idx_tuple in Combinatorics.with_replacement_combinations(1:n, dim)
        val = rand(0.0:0.1:1.0)
        for p_tuple in unique(Combinatorics.permutations(idx_tuple))
            tensor[p_tuple...] = val
        end
    end
    return tensor
end

"""
    get_example_tensors() -> (Array{Float64, 3}, Array{Float64, 3})

Returns the two example tensors A and B used in the project.
"""
function get_example_tensors()
    # Tensor A
    tensor_A = cat(
        [0.3 -0.3; -0.3 0.0],  # Slice [:, :, 1]
        [-0.3 0.0; 0.0 1.0],   # Slice [:, :, 2]
        dims=3
    )

    # Tensor B
    tensor_B = cat(
        [0.7 -0.2; -0.2 -0.2], # Slice [:, :, 1]
        [-0.2 -0.2; -0.2 -0.8],# Slice [:, :, 2]
        dims=3
    )
    
    return tensor_A, tensor_B
end
